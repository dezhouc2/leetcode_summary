
```python
time: o(n*n!)
space: o(n*n!)

注意细节:
如果同一层有重复的数, 考虑先把这个数组排序

回溯的去重有两种方式:
1.用set()

2.剪纸 -> 在函数里的for loop中设置条件已达到剪枝的效果

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        
        #since there are duplicates -> sort
        nums.sort()
        result = []
        curr = []
        viz = [False for i in range(len(nums))]
        
        def backtrack(cur,index):
            if len(cur) == len(nums):
                result.append(cur[:])
                return
            
            for i in range(len(nums)):
                #如果这个数被用过了
                if viz[i] == True:
                    continue
                    
                #这里的viz[i-1] 是表示同一层的后面的一个相同的数是否被过
                if i > 0 and nums[i] == nums[i-1] and viz[i-1] == False:
                    continue
                
                cur.append(nums[i])
                viz[i] = True
                backtrack(cur,index)
                viz[i] = False
                cur.pop()
   
        
        backtrack(curr,0)
        return result




```
