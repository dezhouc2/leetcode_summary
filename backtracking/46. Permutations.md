
```python
time:o(n*n!) 有n个子集, 每一个子集里面有n！个元素
space:o(n) 本质上为递归调用的次数 有多少层就是多少次

思路:
用set() 来记录走过的路径 同时这个set也要同时撤销到原来的父节点 因为每次遍历的时候都是从0开始

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        #q: set 应该放在哪个位置
        
        result = []
        curr = []
        viz = []
        
        def backtrack(cur,index):
            if len(cur) == len(nums):
                result.append(cur[:])
                return
            
            for i in range(len(nums)):
                if nums[i] not in viz:
                    cur.append(nums[i])
                    viz.append(nums[i])
                    
                    backtrack(cur,index)
                    viz.pop()
                    cur.pop()
        
        
        backtrack(curr,0)
        return result




```
