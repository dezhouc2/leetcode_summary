
```python
time: o(n*n!)
space: o(n)


q:去重什么时候用剪枝？什么时候用set?什么时候两个一起用?
a: 当数组中有相同的数的时候 得用剪枝的条件

注意:
这里剪枝的条件是 i-1 >= index and candidates[i] == candidates[i-1] -> i-1 >= index是确保同一层的第一个数后面的数中 如果有相同的话就跳过


class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        
        #since list contains duplicate, we consider to sort the list
        candidates.sort()
        
        result = []
        curr = []
        viz = []
        
        
        def backtrack(cur,index):
            
            #base case for return
            if sum(cur[:]) > target:
                return
            
            if sum(cur[:]) == target:
                result.append(cur[:])
                return
            
            for i in range(index,len(candidates)):
                if i -1>= index and candidates[i-1] == candidates[i]:
                    continue 
                
                
                cur.append(candidates[i])
                #这里注意一下对于下一层的index都为i+1而不是index本身+1
                backtrack(cur,i+1)
                cur.pop()
                   



```
