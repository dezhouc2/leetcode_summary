```
class MinStack:

    def __init__(self):
        self.stack = [] 

    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append((val,val))
        else:
            self.stack.append((val,min(val,self.stack[-1][1])))  #如果栈里面有元素计算此时最小值元素
            

    def pop(self) -> None:
        self.stack.pop()        

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]

time:o(1)
space:o(n)

思路:
需要在常数时间内获取栈的最小值,则不能在getmin()的时候计算最小值 需要在push或pop的时候计算好最小值

方法:
进栈和出栈都是一个元组 (当前值, 插入后栈内最小值)

```
