
```python
time:o(m*n) m = numbers of row and n = numbers of col
space:o(m*n) 

思路:
1.从每一个empty 找到距离空房间最短路径
2.从每一个空房间找empty的最短路径
总结：
方法1会超时因为会有很多empty; 方法2的会更好
如果下次遇到同样类型的题目 先考虑有什么对象可以开始最短路径? 哪个对象更高效一些?

q:两个门会同时shared一个empty 但同一个empty怎么知道对于哪个门才是他的最短路径？
a: 因为两个门是同时遍历(加入queue是前两个)都 以count=0开始向外面扩张 -> 所以必定有一个最短路径(因为queue的加入前后)

class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        
        #多源bfs问题 -> 考虑两个角度
        #1.从门口出发
        #2.从空地出发
        #find nearest gate -> 最短路径问题
        #question: 每一个格子怎么知道选择哪一个gate来计算最短路径
        
        queue = []
        row = len(rooms)
        col = len(rooms[0])
        viz = set()
        
        for i in range(row):
            for j in range(col):
                if rooms[i][j] == 0:
                    queue.append((i,j,0))
                    
        while queue:
            r,c,count = queue.pop(0)
            viz.add((r,c))

            for x,y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:
                if 0 <= x < row and 0 <= y < col:
                    if rooms[x][y] == 2147483647 and rooms[x][y] not in viz:
                        rooms[x][y] = count+1
                        queue.append((x,y,count+1))
                        viz.add((x,y))



```
