```python
time:o(row*col)
space:o(row*col) //worst case all of elements are 0s

思路:
nearest 0 for each cell -> 考虑到最短路径问题 -> 用bfs

下面考虑是从0开始还是从1开始用bfs(做题的时候卡住) -> 如果从0开始当遇到有1的时候就更新1在mat的位置。


class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        
        row = len(mat)
        col = len(mat[0])
        
        queue = []
        visit = set()
        
        for i in range(row):
            for j in range(col):
                if mat[i][j] == 0:
                    queue.append((i,j))
                    visit.add((i,j))
        
        while queue:
            x,y = queue.pop(0)
            
            for r,c in [(x+1,y), (x-1,y),(x,y+1),(x,y-1)]:
                if 0 <= r < row and 0 <= c < col and mat[r][c] == 1 and (r,c) not in visit:
                    mat[r][c] = mat[x][y] + 1
                    queue.append((r,c))
                    visit.add((r,c))
        
        
        return mat



```
