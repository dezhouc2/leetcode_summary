
```python
time:o(n*m) //每一个元素遍历为o(1) 一共有m*n个元素 即 m*n*1
space:o(n) // numbers of element in the queue


注意:
1.这里用grid[i][j] = "#"来标记符号 //也可以用set()
2. if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == "1" 这里要注意先写x和y分别的range 然后再确定grid[x][y] 如果倒过来会有bug


方法一: 直接改变岛屿用"#'
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        #bfs 
        #queue
        
        count = 0
        m = len(grid)
        n = len(grid[0])
        
        def bfs(i,j):

            queue = []
            queue.append((i,j))
            grid[i][j] = "#"

            while queue:
                (i,j) = queue.pop(0)

                for (x,y) in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == "1":
                        queue.append((x,y))
                        grid[x][y] = "#"
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    bfs(i,j)
                    count = count+1
        
        return count


方法二: 用hashset 不改变岛屿

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        #bfs 
        #queue
        
        count = 0
        m = len(grid)
        n = len(grid[0])
        hashset = set()
        
        def bfs(i,j):

            queue = []
            queue.append((i,j))
            hashset.add((i,j))

            while queue:
                (i,j) = queue.pop(0)

                for (x,y) in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == "1" and (x,y) not in hashset:
                        queue.append((x,y))
                        grid[x][y] = "#"
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    bfs(i,j)
                    count = count+1
        
        return count



```
