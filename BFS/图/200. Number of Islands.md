
```python
time:o(n*m) //每一个元素遍历为o(1) 一共有m*n个元素 即 m*n*1
space: o(min(m,n)) // nubmers of row vs numbers of col


注意:
1.这里用grid[i][j] = "#"来标记符号 //也可以用set()
2. if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == "1" 这里要注意先写x和y分别的range 然后再确定grid[x][y] 如果倒过来会有bug


方法一: 直接改变岛屿用"#'
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        #bfs 
        #queue
        
        count = 0
        m = len(grid)
        n = len(grid[0])
        
        def bfs(i,j):

            queue = []
            queue.append((i,j))
            grid[i][j] = "#"

            while queue:
                (i,j) = queue.pop(0)
                ## 注意这里不可以grid[x][y] = "#" 因为

                for (x,y) in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                    if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == "1":
                        queue.append((x,y))
                        grid[x][y] = "#"   ##把append 视为遍历了这个元素 否则可能会造成重复遍历元素的困境
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    bfs(i,j)
                    count = count+1
        
        return count



方法二：dfs
总结: 用dfs的时候考虑的载体是 退出递归的条件, 避免点的重复, 还有四个位置的递归

time:o(m*n)
space:o(m*n) //dfs的空间复杂度 比bfs的空间复杂度高一些

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        m = len(grid)
        n = len(grid[0])
        count = 0
        
        def dfs(i,j):
            if i <0 or i >= m or j < 0 or j == n or grid[i][j] != "1":
                return
                
            #注意这里mark的位置, 一旦遍历完了这个(i,j)点之后就可以mark了
            #这里等价于 queue中 append了元素之后把元素的位置更改
            
            grid[i][j] = "#"    
            
            dfs(i+1,j)
            dfs(i-1,j)
            dfs(i,j+1)
            dfs(i,j-1)
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    dfs(i,j)
                    count = count +1
        
        return count
        


```
