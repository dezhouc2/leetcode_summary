
```python

思路:
查是否有 最短路径 -> 最短路径问题

从examples开始分析 1->2 -> 7 这里的7得通过 index1 然后链接到3然后再到6
这里的 “7通过index1" 暗示了考虑用邻接矩阵 -> 每一个元素对应的value为所有的index；用set() 来表示避免重复

知识点:
邻居矩阵在 找最短路径问题时候的体现

time:o(N^2) N nodes, and each node could have NN edges
space:o(N^2) N nodes each node could have NN edges

class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        
        all_ = {}
        
        for i in range(len(routes)):
            for j in range(len(routes[i])):
                if routes[i][j] not in all_:
                    all_[routes[i][j]] = set()
                    all_[routes[i][j]].add(i)
                
                else:
                    all_[routes[i][j]].add(i)
        print(all_)
        
        queue = [(source,0)]
        vis = set()
        vis.add(source)
        
        while queue:
            stop, count = queue.pop(0)
            
            if stop == target:
                return count
            
            for ele in all_[stop]:
                for e in routes[ele]:
                    if e not in vis:
                        vis.add(e)
                        queue.append((e,count+1))
                
                routes[ele] = []
        
        return -1




```
