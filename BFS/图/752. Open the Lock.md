
```python
time: o(n^2) 猜的 n -> numbers of nodes
space:o(k) k -> numbers of elements in queue and numbers of elements in hashset

思路:
找到最短路径 -> 最短路径问题 -> 把问题抽象成图然后从 "0000"开始用bfs 

这个问题抽象成图: (每一个node为 "0000" 到 "9999"之间的数值) 边的话为两个点之间相差一个digit
            (0,0,0,0)
第一层: (1,0,0,0), (9,0,0,0), (0,1,0,0) (0,9,0,0) (0,0,1,0) (0,0,9,0) (0,0,0,1) (0,0,0,9)

注意:
edge case
数据预处理 -> 把数值变成tuple

class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        
        #base case
        if "0000" in deadends:
            return -1
        
        #pre setting up for the needs
        target = tuple(map(int, target))
        result = []
        for ele in deadends:
            ele = tuple(map(int, ele))
            result.append(ele)
        
        hashset = set(result)
        queue = [((0,0,0,0),0)]
        hashset.add((0,0,0,0))
        
        list_all = [
            (1,0,0,0),
            (-1,0,0,0),
            (0,1,0,0),
            (0,-1,0,0),
            (0,0,1,0),
            (0,0,-1,0),
            (0,0,0,1),
            (0,0,0,-1),
        ]
        
        while queue:
            point, count = queue.pop(0)
            if point == target:
                return count
            
            for list_ in list_all:
                new_x = (list_[0] + point[0]) % 10
                new_y = (list_[1] + point[1]) % 10
                new_z = (list_[2] + point[2]) % 10
                new_h = (list_[3] + point[3]) % 10
                
                if (new_x, new_y, new_z, new_h) not in deadends and (new_x, new_y, new_z, new_h) not in hashset:
                    
                    queue.append(((new_x, new_y, new_z, new_h), count+1))
                    hashset.add((new_x, new_y, new_z, new_h))
        
        return -1



```
