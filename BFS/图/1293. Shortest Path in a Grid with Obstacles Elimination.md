
```python
time: o(n*K) n -> numbers of cell, k-> numbers of obstacles
space: o(n*K)

思路:
对了障碍物加了一个维度去判断是否可以遍历

q1: 怎么确保选择点k个障碍物是可以让我达到最短路径的k个障碍物?

        
        row = len(grid)
        col = len(grid[0])

        #k = min(k, row+col-3)
        queue = [(0,0,k,0)]
        hashset = set()
        hashset.add((0,0,k))
        
        
        
        while queue:
            r,c, obs, count = queue.pop(0)
            if (r,c) == (row-1,col-1):
                return count
            
            for x,y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:
                if 0 <= x < row and 0 <= y < col:
                    
                    curr = obs - grid[x][y]
                    
                    #can't go this way
                    if curr < 0 or (x,y,curr) in hashset: ##注意这个 (x,y,curr) 因为有了k的数量之后会有重复对一个cell遍历的情况
                        continue
                    
                    #如果 curr>= 0 不管是不是障碍都可以穿越
                    queue.append((x,y,curr,count+1))
                    hashset.add((x,y,curr))
        
        return -1



```
