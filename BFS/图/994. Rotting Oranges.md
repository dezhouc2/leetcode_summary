
```python
time:o(row*col) worst cases size of the grid
space:o(row*col) worst cases size of the grid

思路卡住的地方: 最后输出的count应该在什么地方进行递增？
a: 每一个minute的增加都在每一层的元素(for ...)全部pop out之后; 本质上minute的增加相当于树的层, 每一层就是一个min, 有多少层就有多少个min

note: bfs中的另外一种计数方法除了可以用另外的变量来表示。

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        
        row = len(grid)
        col = len(grid[0])
        queue = []
        count = 0
        
        for i in range(row):
            for j in range(col):
                if grid[i][j] == 2:
                    queue.append((i,j,count))
        #根据层次来迭代count
        
        while queue:
                r,c,count = queue.pop(0)
                
                for x,y in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                    if 0 <= x < row and 0 <= y < col and grid[x][y] == 1:
                        
                        queue.append((x,y,count+1))
                        grid[x][y] = 2
        
        for i in range(row):
            for j in range(col):
                if grid[i][j] == 1:
                    return -1
        return count



```
