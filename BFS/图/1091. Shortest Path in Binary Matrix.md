
```python
time:o(n) worst case is to wander all cells in the grid
space:o(n)

这道题没有做到bug free -> 注意一下 base case -> 即当初始点和终点都为1的时候直接输出

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        
        row = len(grid)
        col = len(grid[0])
        viz = set()
        viz.add((0,0))
        queue = [(0,0,1)]
        
        if grid[0][0] == 1 or grid[row-1][col-1] == 1:
            return -1
        
        while queue:
            r,c, count = queue.pop(0)
            
            if (r,c) == (row-1,col-1):
                return count
            
            #8 directions
            for x,y in [(r+1,c), (r-1,c),(r,c+1),(r,c-1), (r+1,c+1),(r-1,c-1),
                       (r-1,c+1),(r+1,c-1)]:
                
                if 0 <= x < row and 0 <= y < col and grid[x][y] == 0 and (x,y) not in viz:
                        queue.append((x,y,count+1))
                        viz.add((x,y))
        
        return -1





```
