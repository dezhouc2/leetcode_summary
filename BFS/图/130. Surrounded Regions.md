
```python
time:o(n) n -> numbers of cell in the board
space:o(n)

思路:
一共有两个连通分量, 一种在edge, 另外一种在中间
1.先把在edge的 转化为 “#”
2.剩下的连通分量为 在中间的 -> 把这些连通分量转化为 "x" 最后再把edge的转化回“o"

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        
        #如果不改变board的结构应该怎么处理?
        #two types of "O"
        
        row = len(board)
        col = len(board[0])
        
        def bfs(i,j):
            queue = []
            queue.append((i,j))
            
            while queue:
                r,c = queue.pop(0)
                board[r][c] = "#"
                
                for x,y in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:
                    if 0 <= x < row and 0 <= y < col and board[x][y] == "O":
                        queue.append((x,y))
                        
                        #这里注意要加 “#” 否则会超时 虽然理论上不加没问题
                        board[x][y] = "#"
        
        #deal with row - 0
        for i in range(row):
            if board[i][0] == "O":
                bfs(i,0)
            
            if board[i][col-1] == "O":
                bfs(i,col-1)
        
        #deal with row - col-1
        for j in range(col):
            if board[0][j] == "O":
                bfs(0,j)
            
            if board[row-1][j] == "O":
                bfs(row-1,j)
        
        for i in range(row):
            for j in range(col):
                if board[i][j] == "O":
                    board[i][j] = "X"
                
        for i in range(row):
            for j in range(col):
                if board[i][j] == "#":
                    board[i][j] = "O"



``
