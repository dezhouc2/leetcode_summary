
```python
time:o(M*N) M is the number of rows and N is the number of cols
#worst case visiting all cells in the matrix

space:o(M*N) extra space comes from both queue and hashset
#worst case filling all cells in the (queue + hashset)


知识点:
set.interseciton()  # returns a set that contains same elements between two or more sets
eg: set.intersection(set1)


想法: 
to both pacific and atlantic oceans -> 可以考虑先用一个集合来表示pacfic所有的rain water;再用另外一个集合表示atlantic 所有的rain water 最后再interaction

考虑edge case -> 左边和上边全部都是pacific ocean的; 右和下边全部都是atlantic ocean

然后考虑中间的部分 -> 对每一个rain water使用bfs?
正确想法: 
通过左边上边为pacific ocean的部分使用bfs 使得找到 “中间属于pacifc ocean”的部分, 同理得 中间atlantic ocean的部分 即可得到所有pacific和atlantic分别的所有的部分

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        
        row = len(heights)
        col = len(heights[0])
        
        pac_ = []
        atl_ = []
        
        for i in range(row):
            pac_.append((i,0))
            atl_.append((i,col-1))
        
        for j in range(col):
            pac_.append((0,j))
            atl_.append((row-1,j))
        
        #bfs
        def bfs(queue):
            visit = set()
            
            while queue:
                r,c = queue.pop(0)
                visit.add((r,c))
                
                for x,y in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                    if 0 <= x < row and 0 <= y < col and (x,y) not in visit and heights[x][y] >= heights[r][c]:
                        queue.append((x,y))
        
            return visit
        
        pac_all = bfs(pac_)
        atl_all = bfs(atl_)
        
        return list(pac_all.intersection(atl_all))
    






```
