
```
自己的做法:
time:o(n)
space:o(n)

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        
        hashset = set()
        
        while head:
            if head not in hashset:
                hashset.add(head)
                head = head.next
            
            else:
                return True
        
        return False


做法二:
time:o(n)
space:o(1)

条件: o(1) -> 考虑链表常用空间为o(1)的常用操作 -> 双指针/快慢指针

遍历这个链表的条件: 快指针不等于慢指针

case1: 无环 -> 因为快指针比慢指针走的快 那么是要考虑快指针或快的下一个指针是否为null即可
case2: 有环 -> 因为快指针比慢指针快 所以必定会重合 -> 重合的时候输出

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        
        slow = head
        fast = head.next
        
        while slow != fast:
            if not fast or not fast.next:
                return False
            else:
                slow = slow.next
                fast = fast.next.next
        
        
        return True




```
