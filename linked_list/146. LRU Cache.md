

```
思路:
这里用到一个数据结构 OrderedDict (如果面试遇到用白板的话得import) -> 一定要清楚为什么可以用这个数据结构和 这个数据结构的复杂度

why:
1.move index of the key -> think of ordereddict
2.evict the least used key -> think about popitem() function 

知识点:
OrderedDict 也是类型dict()的用法, 唯一不一样的地方是ordereddict 会track每一个key的index;但dict不会

两个常用function:\
move_to_end(key,last = true):\
把一个在的key移动到最后; 如果last = false把一个在的key移动在最前

popitem(last=true):\
returns and removes a (key,value) pair\ 
pairs are returned in last in first out order if last is true\
last is false -> returned in first in first out order\

注意:
在put function 我之前写\
if key in self:
  self.move...
else:
  self[key] = value 

这个做法是错的 因为这样的话没办法在key in self的情况 update key对应的value


做法:
time:o(1)
space:o(capacity)

from collections import OrderedDict

#use collections.OrderDict
class LRUCache(OrderedDict):

    def __init__(self, capacity: int):
        self.capacity = capacity


    def get(self, key: int) -> int:
        if key in self:
            self.move_to_end(key,last=True)
            return self[key]
        else:
            return -1

    def put(self, key: int, value: int) -> None:
        if key in self:
            self.move_to_end(key)
        self[key] = value
        
        if len(self) > self.capacity:
            self.popitem(last=False)








```
