
```

做法一:(recursive)
time:o(m+n)
space:o(m+n)

想法:
对比两个list的头节点的值, 小的那个的下一个指针指向大的list的头节点 -> 以此类推(这里考虑到用递归)

注意:
line 28 输出到的是list2 是因为list2的头节点在为整个输出 链表的头节点所以得输出list2
同理得line 33


class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        
        #recursive 
        
        if not list1:
            return list2
        
        if not list2:
            return list1
        
        if list1.val > list2.val:
            list2.next = self.mergeTwoLists(list1,list2.next)
            return list2
        
        else:
            list1.next = self.mergeTwoLists(list1.next,list2)
            return list1


做法二:
思路:
time:o(n)
space:o(1)

用一个假节点(listnode) 来连接节点 因为两个链表在移动的过程当中找不到head

必定有一个链表的节点先遍历完 那么得把这个先遍历完的链表的最后一个节点也连接上另外一个链表

注意:
dummy = listnode() 和 dummy = none 的区别

        
        dummy = ListNode()
        pre = dummy
        
        # dummy -> 1 -> 1 -> 2 -> 3 -> 4
        # pre     pre.next
        
        
        while list1 and list2:
            if list1.val <= list2.val:
                pre.next = list1
                list1 = list1.next
            
            else:
                pre.next = list2
                list2 = list2.next
            
            pre = pre.next
        
        if not list1:
            pre.next = list2
        else:
            pre.next = list1
        
        return dummy.next



```
