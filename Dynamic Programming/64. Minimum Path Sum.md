
```python
time:o(k) k = numbers of cells in the grid
space:o(k)

dp算法的题眼:
最大/最小值 (本质上也是可以用bfs, bfs的延伸其实就是dp)

思路:
这道题可以用dp的理由是 最小路径的合是取决于上一步的路径

然后分类讨论:
只走右边路径 -> 在建立好的dp matrix里面填好右边路径每一步的步数
只走下面路径 -> 在建立好的dp matrix里面填好左边路径每一步的步数
其他路径 

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        
        row = len(grid)
        col = len(grid[0])
        
        #这里得根据grid中的row和col的行数来写清楚
        dp = [[0]*col for i in range(row)]
        
        dp[0][0] = grid[0][0]
        
        for i in range(row):
            for j in range(col):
                if i == 0 and j != 0:
                    dp[i][j] = grid[i][j] + dp[i][j-1]
                
                elif i != 0 and j == 0:
                    dp[i][j] = grid[i][j] + dp[i-1][j]
                
                elif i != 0 and j != 0:
                    dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
        
        return dp[row-1][col-1]
        






```
