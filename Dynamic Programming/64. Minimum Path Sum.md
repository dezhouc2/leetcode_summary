
```python
time:o(k) k = numbers of cells in the grid
space:o(k)

思路:
这道题可以用dp的理由是 最小路径的合是取决于上一步的路径
然后分类讨论:
只走右边路径
只走下面路径
其他路径 


class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        
        m, n = len(grid), len(grid[0])

        # 状态定义：dp[i][j] 表示从 [0,0] 到 [i,j] 的最小路径和
        dp = [[0] * n for _ in range(m)]

        # 状态初始化
        dp[0][0] = grid[0][0]

        # 状态转移
        for i in range(m):
            for j in range(n):
                if i == 0 and j != 0:
                    dp[i][j] = grid[i][j] + dp[i][j - 1]
                elif i != 0 and j == 0:
                    dp[i][j] = grid[i][j] + dp[i - 1][j]
                elif i != 0 and j != 0:
                    dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])

        # 返回结果
        return dp[m - 1][n - 1]






```
