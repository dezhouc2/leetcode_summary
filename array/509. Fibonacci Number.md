```
解法一: dp
总结:
注意: base case 当n等于0,等于1的分别情况
time:o(n) space:o(n)

class Solution:
    def fib(self, n: int) -> int:       
        
        if n == 0:
            return 0
        if n == 1:
            return 1
        
        dp = [0]*(n+1)
        
        dp[1] = 1
        for i in range(2,len(dp)):
            dp[i] = dp[i-1] + dp[i-2]
        
        return max(dp)

解法二: 不用额外的空间
time:o(n) space:o(1)
思路:
通过result 这个变量来代替 dp[i]的空间, 那么dp[i-1],dp[i-2]就得让x,y来进行迭代。

dp[i-1]  dp[i-2]   dp[i]     
  x         y      result
 
 现在考虑用 x 代替 y, y 代替x即可

class Solution:
    def fib(self, n: int) -> int:
        # x = 0, y = 1, r = y+x,  
        # 0, 1, 1, 2
        
        result = 0
        x = 0
        y = 1
        if n == 0:
            return x
        
        if n == 1:
            return y
        
        for i in range(2, n+1):
            result = x+y
            x = y
            y = result
       
       return result

```
