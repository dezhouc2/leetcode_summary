

```
思路:

time:o(n)
space:o(1)
s(i,j) = min(height[i],height[j]) * (j-i)
为了让面积尽量大 (j-i)要尽量大 -> 这里考虑用双指针因为j从最后一个数开始 确定了一个维度

现在考虑怎样才能让height尽量高 -> 面积取决于小的height所以考虑让小的height的指针移动(通过example1也知道 为了多捕捉高的面积的可能性)

如果i==j的话说明重叠长的纬度为0所以要用i < j

class Solution:
    def maxArea(self, height: List[int]) -> int:
        
        rest = 0
        i = 0
        j = len(height)-1
        
        while i < j:
            
            if height[i] > height[j]:
                rest = max(rest,height[j]*(j-i))
                j = j -1
            
            else:
                rest = max(rest, height[i]*(j-i))
                i = i+1
        
        return rest



```
