```python
注意: 还没做到bug free -> 考虑base, 写完coding 自己dry run一下

思路1:
因为要用到index, 和值 所以考虑到用 dictionary
利用target和当前值做差, 判断差是否在dicionary中如果在输出

time:o(n), space:o(n)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        result = []
        dic = dict()
        
        for i in range(len(nums)):
            need = target - nums[i]
        
            if need in dic:
                result.append(dic[need])
                result.append(i)
                return result
            
            else:
                dic[nums[i]] = i
                
                
思路2: 双指针
情况1: 如果是排序好的话
       l = 0
        r = len(nums)-1
        
        while l < r:
            if nums[l] + nums[r] == target:
                return [l,r]
            
            elif (nums[l] + nums[r]) < target:
                l = l+1
            
            else:
                r = r-1
        



情况2: 如果还没排序好的话
    class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        numss = [(i,nums[i]) for i in range(len(nums))]
        numss.sort(key= lambda x:x[1])
        l,r = 0,len(nums)-1
        
        while l < r:
            if numss[l][1] + numss[r][1] == target:
                return [numss[l][0],numss[r][0]]
            
            elif (numss[l][1] + numss[r][1]) < target:
                l = l+1
            
            else:
                r = r-1


```
