
```
思路:
time:o(nlogn)
space:o(n)

和 56.merge interval思路类似 但是 line29 -30这个部分 如果没有更多的examples不好想 只能猜

从example 1 可以知道 -> 把line17的interval删去即可;line18的interval会和line16的interval进行对比 这个说明result[-1][1]会要比较之下更小的数值


class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        
        #interval 问题
        #排序
        #画图
        
        # 1..2
        # 1.....3
        #    2..3
        #    2..5      
        
        intervals.sort(key=lambda x:x[0])
        count = 0
        
        result =[intervals[0]]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] < result[-1][1]:
                result[-1][1] = min(result[-1][1],intervals[i][1])
                count = count+1
            
            else:
                result.append(intervals[i])
        
        return count




```
