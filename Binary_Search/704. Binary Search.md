
```python 
time: o(logn)
space: o(1)

q: why binary search is logn?
a: each time binary search is gonna divided by 2, but how many times that binary search need to do so?
a_: log 2^(n) = x -> x times

思路:
因为是sorted的数组所以 如果nums[mid] > target的话说明 nums[mid+1]...nums[mid+2] 都会大于target 所以要在mid-1设置重新binary search 同理得< target

q: why l <= r
a: 如果 l == r的时候 nums[mid]还是可以用来判断是否为target


class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        l = 0
        r = len(nums)-1
        
        # [-1,0,3,5,9,12]
        #     l 
        #     r  
        
        while l <= r:
            mid = (l+r) //2
            if nums[mid] == target:
                return mid
            
            elif nums[mid] > target:
                r = mid-1
            
            else:
                l = mid+1
        
        return -1




```
