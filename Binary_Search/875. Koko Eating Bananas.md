
```python
time: o(log(m)*numbers of piles) m = length from (1....max(piles))
space:o(1)

思路:
edge case:
这道题要考虑k, k的范围为 [1, max(piles)]; 为什么是max(piles)? -> 如果k为这个piles中最大的数值那么必定能在h小时之内吃完

从简单情形考虑 -> 当k=max(piles)的时候让每一个堆的香蕉数量除以 k = 小时数, 然后看这个小时数是否在h的区间之内 如果是的话考虑更小的k因为我们要使得到最小的k


技巧:
这道题用 math.ceil() //Round a number upward to its nearest integer

math.ceil(1.0) # 1
math.ceil(1.1) # 2


class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        #we search from [1, max(piles)] 
        #base cases at least k = max(piles)
        #constrain = len(piles) <= h
        
        
        l = 1
        r = max(piles)
        final = r
        
        while l <= r:
            mid = (l+r)//2
            
            hour = 0
            for ele in piles:
                hour = hour + math.ceil(ele/mid)
            
            if hour > h:
                l = mid+1
            elif hour <=h:
                r = mid -1
                final = min(final,mid)
        
        return final
                




```
