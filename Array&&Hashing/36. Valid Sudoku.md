
```python
time:o(9^2)  如果不是常数的话为 o(n^2)
space:o(9^2)

思路:
  思考怎么对每一行/每一列/每一个框可以确保没有duplicate -> 考虑到hashset -> 每一行/列/框框建立一个set 利用collections.defaultdict(set)

注意:
  考虑框框时候怎么确定对任意(r,c) 都在特定的框框里? -> 每一个框框的范围为 (r//3,c//3) 因为每一个pattern的长/宽为3 
  

class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        
        #use dictionary to represent the three kinds of rules
        rows = collections.defaultdict(set)
        cols = collections.defaultdict(set)
        square = collections.defaultdict(set)
        
        row = len(board)
        col = len(board[0])
        
        for i in range(row):
            for j in range(col):
                if board[i][j] == ".":
                    continue
                
                #这么写的好处为因为set() 都是空白的都是一起加入 即这个加入的数为唯一的 所以只要这个唯一的数在加入之前就在contradict
                if board[i][j] in rows[i] or board[i][j] in cols[j] or board[i][j] in square[(i//3,j//3)]:
                    return False
                
                else:
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    square[(i//3,j//3)].add(board[i][j])
        
        return True



错误的思路:
                #这里有一个反例为只要3个情况一个情况不在即可 其他两个情况都可以在即已经遍历过了
                elif board[i][j] not in rows[i] or board[i][j] not in cols[j] or board[i][j] not in square[(i//3,j//3)]:
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    square[(i//3,j//3)].add(board[i][j])
                
                else:
                    return False
        
        return True








```
