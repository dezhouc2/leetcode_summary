
```python
complete binary tree(定义):
1.all leaf element must learn towards left
2.last leaf element may not have right sibling

example:
        1
      2   3
    6

heapq:
*--定义:
tree-based data structure(complete tree)
分为两个heap(min heap, max heap); Python 默认的是min heap
Min heap(小堆) - In a min heap, every parent node has a value that is less than or equal to any of its children. 
Max heap(大堆 ) - In a max heap, every parent node has as value that is greater or equal to any of its children.

zero-based indexing -heap[0] is smallest item or largest item

自己的话描述:
minheap,maxheap 的本质为complete binary tree 
minheap: tree的node的值小于等于他的children的值
maxheap: tree的node的值大于等于他的children 的值

*--性质(time complexity):    
(space complexity) -> O(n)
operation:                         Big(o)                     Python中的操作
Find max/min                       O(1)                       heap[0]
Insert                             O(log n)                   heapq.heappush(heap, element)
Remove                             O(log n)                   heapq.heappop(heap)
Heapify                            O(n)                       heapq.heapify(list)


*--Techinques(when to use heap):
necessary to repeatedly remove the object with the highest (or lowest) priority -> leetcode meeting room2
Mention of k

*-- 做题思路:
1.用list来实现heap eg: hp = []
2.把元素heapq.heappush()  #一般来说 element的形式为tuple
3.根据题目的意思 用while 循环留下几个需要的元素作为输出

*--Implementation notes:
如果想让heap为maxheap -> 只需要把所有的值*-1即可

heapq.heappush(hp, (value1,value)) #默认根据value1来对比的

heapq.nlargest(n, data): return n numbers of largest element in data
heapq.nsmallest(n, data): ...

example:
data = [1,5,3,2,8,5]
print(heapq.nlargest(3,data)) // [8,5,5]
print(heapq.nsmallest(3,data)) // [1,2,3]

```
